To do
-----

Visual clipboard functionality: Cut, Copy & Paste.

Multiple selection in the designer.

Better default property handling, possibly cutting some cruft from
generated source by omitting unchanged defaults.

Native design time sizer support. I ran into a hitch while doing the
collection editors. Currently only one type of collection insertion
method is supported e.g. wxToolbar.AddTool().
Sizers need various methods and will be done as soon as I overcome this
limitation.
Menus will then also support sub-menus and separators.

Constructor style property editor

Zope object creation/clipboard support.

CVS update/diff/commit support (I need it, so Boa's getting it)
There are also a few interesting possiblilities to integrate merge
facilities into the editor.

C++, Makefile support. Personally I plan very basic support and hope
that someone else will take this further. This should expand into
useful facilities for extension writing.

Useful debugging!


Detail
------

Help
- From Inspector on property

Documentation View
- Add functions to documentation
- Option: Don't print empty sections

Zope
- Propery editing (Maybe in Inspector)
  - Parse <FORM> tags from zope prop pages?
  - XMLRPC

Collection editors
- Move up, move down

Debugging
- Emulating the mainloop
- Breaking into running code??


Scriblings
----------

Refactoring tools
* Expand ExploreView to show params & method next to tree
* Refactorings
  * Move selection to method
     - Input: selection, method name
     - Process: Identify local variables
                      Pass vars as parameters
                      Correct indentation

  * Extract common expression
     - Input: common expr (selection), source (selection), new_name
     - Process: Find all occurences of common expr in source
                      Add initialiser above first use of source: 	
                          new_name = common_expr
                      Replace occurences with new_name

  * Renaming of Classes/Methods/Functions/Modules within an app,
     - This seems incredibly hard to do 100% correct given Python's 
       dynamic nature, but there are interesting possibilities in
       post mortem inspection of profiler statistics.
       With a thorough test suite an accurate log of all every 
       access to a certain function is recorded.
       This leads to...

  * Testing facilities, how should GUI classes be tested?
     - Window scraping sucks!
     - Look into PyUnit
     - Strategies:
       - Methods (as opposed to event methods) could be tested with doctest.py
         another Tim Peters module :)
         Maybe it can be extended to handle events as follows:
         - List of events that can be posted and assertion of certain 
           control values after posting
         I am not very optimistic about this route as none of my own GUI
         objects seem testable in a few lines and usually depend on other
         frames being open/initialised. Nevertheless this needs to be
         pursued and at least those that are testable should be tested.
                      
* Code tools/shortcuts
  * Expand creation params:
    class MyClass(YourClass):
        def __init__(self, param1, param2, ...):
    to:
    class MyClass(YourClass):
        def __init__(self, param1, param2, ...):
            YourClass.__init__(self, param1, param2, ...)
            self.param1 = param1
            self.param2 = param2
            ...

  * Window id registration:
	wxID_*
    to:
    [wxID_*, ...] = map(lambda i: wxNewId(), range(n))

  * Event creation:
	EVT_*(self, id, self.OnEvtFunc) 
    to:
        def OnEvtFunc(self, event):
            |





UML
* Update attibutes in uml

Look at Idle's class browser source parser and Idle extensions

_Fundamental changes_

Handle more than one class per source file

Add inheritable components


Add revision entry frmt:
# Revision 1.23  1999/08/03 20:49:05  riaan